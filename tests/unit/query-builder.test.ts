/**
 * Unit tests for query builder in ageSchemaClient
 *
 * These tests verify that the QueryBuilder can properly build Cypher queries
 * without requiring a predefined schema or database connection.
 *
 * The tests focus on ensuring that all Cypher query patterns used in the integration tests
 * can be properly generated by the query builder.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { QueryBuilder } from '../../src/query/builder';
import { QueryExecutor } from '../../src/db/query';
import { SchemaDefinition } from '../../src/schema/types';
import { OrderDirection } from '../../src/query/types';
import { QueryExecutionOptions } from '../../src/query/types';

// Mock schema definition based on the movie schema used in integration tests
const mockSchema: SchemaDefinition = {
  version: '1.0.0',
  vertices: {
    Movie: {
      properties: {
        id: { type: 'integer' },
        title: { type: 'string' },
        year: { type: 'string' },
        genre: { type: 'string' },
        rating: { type: 'number' },
        directorId: { type: 'integer' }
      },
      required: ['id', 'title']
    },
    Person: {
      properties: {
        id: { type: 'integer' },
        name: { type: 'string' },
        born: { type: 'integer' }
      },
      required: ['id', 'name']
    }
  },
  edges: {
    DIRECTED: {
      properties: {},
      fromVertex: 'Person',
      toVertex: 'Movie'
    }
  },
  metadata: {
    description: 'Movie database schema for query builder unit tests'
  }
};

// Mock query executor
const mockExecutor = {
  executeCypher: vi.fn().mockResolvedValue({ rows: [] }),
  executeSQL: vi.fn().mockResolvedValue({ rows: [] })
} as unknown as QueryExecutor;

describe('QueryBuilder Unit Tests', () => {
  let queryBuilder: QueryBuilder<typeof mockSchema>;

  beforeEach(() => {
    // Create a new query builder for each test
    queryBuilder = new QueryBuilder(mockSchema, mockExecutor, 'test_graph');
    vi.clearAllMocks();
  });

  // Test: Basic MATCH query
  it('should build a basic MATCH query', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title', 'm.year AS year')
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.year AS year');
  });

  // Test: MATCH with WHERE clause
  it('should build a MATCH query with WHERE clause', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .where('m.genre = $genre', { genre: 'Drama' })
      .return('m.title AS title', 'm.genre AS genre')
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.genre = $genre');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.genre AS genre');
    expect(queryBuilder.getParameters()).toEqual({ genre: 'Drama' });
  });

  // Test: MATCH with ORDER BY clause
  it('should build a MATCH query with ORDER BY clause', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title', 'm.rating AS rating')
      .orderBy('m.rating', OrderDirection.DESC)
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.rating AS rating');
    expect(cypherQuery).toContain('ORDER BY m.rating DESC');
  });

  // Test: MATCH with LIMIT clause
  it('should build a MATCH query with LIMIT clause', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title')
      .orderBy('m.title')
      .limit(3)
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title');
    expect(cypherQuery).toContain('ORDER BY m.title ASC');
    expect(cypherQuery).toContain('LIMIT 3');
  });

  // Test: MATCH with SKIP clause
  it('should build a MATCH query with SKIP clause', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title')
      .orderBy('m.title')
      .skip(2)
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title');
    expect(cypherQuery).toContain('ORDER BY m.title ASC');
    expect(cypherQuery).toContain('SKIP 2');
  });

  // Test: MATCH with relationship
  it('should build a MATCH query with relationship', () => {
    const cypherQuery = queryBuilder
      .match('Person', 'p')
      .outgoing('DIRECTED', 'd', 'Movie', 'm')
      .done()
      .return('p.name AS director', 'm.title AS movie')
      .toCypher();

    // The current implementation generates separate MATCH clauses
    expect(cypherQuery).toContain('MATCH (p:Person)');
    expect(cypherQuery).toContain('(p:Person)-[d:DIRECTED]->(m:Movie)');
    expect(cypherQuery).toContain('RETURN p.name AS director, m.title AS movie');
  });

  // Test: MATCH with aggregation
  it('should build a MATCH query with aggregation', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.genre AS genre', 'count(m) AS count')
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.genre AS genre, count(m) AS count');
  });

  // Test: MATCH with multiple patterns
  it('should build a MATCH query with multiple patterns', () => {
    const cypherQuery = queryBuilder
      .match('Person', 'p')
      .done()
      .match('Movie', 'm')
      .done()
      .where('m.directorId = p.id')
      .return('p.name AS director', 'm.title AS movie')
      .toCypher();

    expect(cypherQuery).toContain('MATCH (p:Person)');
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.directorId = p.id');
    expect(cypherQuery).toContain('RETURN p.name AS director, m.title AS movie');
  });

  // Test: MATCH with WITH clause
  it('should build a MATCH query with WITH clause', () => {
    const cypherQuery = queryBuilder
      .match('Person', 'p')
      .done()
      .with('p')
      .match('Movie', 'm')
      .done()
      .where('m.directorId = p.id')
      .return('p.name AS director', 'collect(m.title) AS movies')
      .toCypher();

    expect(cypherQuery).toContain('MATCH (p:Person)');
    expect(cypherQuery).toContain('WITH p');
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.directorId = p.id');
    expect(cypherQuery).toContain('RETURN p.name AS director, collect(m.title) AS movies');
  });

  // Test: MATCH with UNWIND clause
  it('should build a MATCH query with UNWIND clause', () => {
    const cypherQuery = queryBuilder
      .unwind('$movieIds', 'movieId')
      .match('Movie', 'm')
      .done()
      .where('m.id = movieId')
      .return('m.title AS title')
      .toCypher();

    expect(cypherQuery).toContain('UNWIND $movieIds AS movieId');
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.id = movieId');
    expect(cypherQuery).toContain('RETURN m.title AS title');
  });

  // Test: Complex query with multiple clauses
  it('should build a complex query with multiple clauses', () => {
    const cypherQuery = queryBuilder
      .match('Person', 'p')
      .done()
      .with('p')
      .match('Movie', 'm')
      .done()
      .where('m.directorId = p.id')
      .with('p.name AS director', 'collect(m) AS movies')
      .unwind('movies', 'movie')
      .return('director', 'movie.title AS title', 'movie.year AS year')
      .orderBy('year', OrderDirection.DESC)
      .toCypher();

    expect(cypherQuery).toContain('MATCH (p:Person)');
    expect(cypherQuery).toContain('WITH p');
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.directorId = p.id');
    expect(cypherQuery).toContain('WITH p.name AS director, collect(m) AS movies');
    expect(cypherQuery).toContain('UNWIND movies AS movie');
    expect(cypherQuery).toContain('RETURN director, movie.title AS title, movie.year AS year');
    expect(cypherQuery).toContain('ORDER BY year DESC');
  });

  // Test: Parameter handling with withParam method
  it('should handle parameters with withParam method', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .withParam('minRating', 8.5)
      .where('m.rating >= $minRating')
      .return('m.title AS title', 'm.rating AS rating')
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.rating >= $minRating');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.rating AS rating');
    expect(queryBuilder.getParameters()).toEqual({ minRating: 8.5 });
  });

  // Test: Parameter handling with Apache AGE compatibility
  it('should handle parameters with Apache AGE compatibility using WITH clause', () => {
    // Mock the execute method to test the parameter handling
    const executeMock = vi.spyOn(queryBuilder as any, 'execute');

    // Set up parameters
    queryBuilder
      .match('Movie', 'm')
      .done()
      .withParam('minRating', 8.5)
      .withParam('genre', 'Drama')
      .where('m.rating >= $minRating AND m.genre = $genre')
      .return('m.title AS title', 'm.rating AS rating');

    // Execute the query
    queryBuilder.execute({} as QueryExecutionOptions);

    // Check that the execute method was called with the correct parameters
    expect(executeMock).toHaveBeenCalled();

    // Get the parameters that would be used
    const params = queryBuilder.getParameters();
    expect(params).toEqual({ minRating: 8.5, genre: 'Drama' });
  });

  // Test: Using withParamFunction for Apache AGE compatibility
  it('should use withParamFunction for Apache AGE compatibility', () => {
    const cypherQuery = queryBuilder
      .withParamFunction('schema.get_params', 'params')
      .match('Movie', 'm')
      .done()
      .where('m.rating >= params.minRating AND m.genre = params.genre')
      .return('m.title AS title', 'm.rating AS rating')
      .toCypher();

    expect(cypherQuery).toContain('WITH schema.get_params() AS params');
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('WHERE m.rating >= params.minRating AND m.genre = params.genre');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.rating AS rating');
  });

  // Test: Vertex property constraints in match clause
  it('should handle vertex property constraints in match clause', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .where('title', '=', 'The Godfather')
      .done()
      .return('m.title AS title', 'm.year AS year')
      .toCypher();

    // The implementation should add property constraints to the vertex pattern
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.year AS year');

    // Check that the property constraint is added to the vertex pattern
    // Note: This test might need adjustment based on how property constraints are implemented
    // in the actual MatchClause.where method
  });

  // Test: Bidirectional relationship
  it('should build a query with bidirectional relationship', () => {
    const cypherQuery = queryBuilder
      .match('Person', 'p1')
      .related('DIRECTED', 'r', 'Movie', 'm')
      .done()
      .return('p1.name AS person', 'm.title AS movie')
      .toCypher();

    // The current implementation generates separate MATCH clauses
    expect(cypherQuery).toContain('MATCH (p1:Person)');
    expect(cypherQuery).toContain('(p1:Person)-[r:DIRECTED]-(m:Movie)');
    expect(cypherQuery).toContain('RETURN p1.name AS person, m.title AS movie');
  });

  // Test: Incoming relationship
  it('should build a query with incoming relationship', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .incoming('DIRECTED', 'r', 'Person', 'p')
      .done()
      .return('m.title AS movie', 'p.name AS director')
      .toCypher();

    // The current implementation generates separate MATCH clauses
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('(p:Person)-[r:DIRECTED]->(m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS movie, p.name AS director');
  });

  // Test: Query validation against schema
  it('should validate query against schema', () => {
    // This test verifies that the validateQuery method works correctly
    const validationErrors = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title', 'm.year AS year')
      .validateQuery();

    expect(validationErrors).toEqual([]);
  });

  // Test: Query validation with invalid label
  it('should detect invalid labels during validation', () => {
    // Create a query builder with an invalid vertex label
    const invalidQueryBuilder = new QueryBuilder(mockSchema, mockExecutor, 'test_graph');

    // Build a query with an invalid label
    invalidQueryBuilder
      .match('InvalidLabel' as any, 'i')
      .done()
      .return('i.name AS name');

    // Validate the query
    const validationErrors = invalidQueryBuilder.validateQuery();

    // Check that the validation detected the invalid label
    expect(validationErrors.length).toBeGreaterThan(0);
    expect(validationErrors[0]).toContain('Invalid vertex label');
  });

  // Test: Multiple ORDER BY clauses
  it('should handle multiple ORDER BY clauses', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title', 'm.year AS year', 'm.rating AS rating')
      .orderBy('m.year', OrderDirection.DESC)
      .orderBy('m.rating', OrderDirection.DESC)
      .toCypher();

    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title, m.year AS year, m.rating AS rating');
    expect(cypherQuery).toContain('ORDER BY m.year DESC, m.rating DESC');
  });

  // Test: Reset query builder
  it('should reset the query builder state', () => {
    // Build a query
    queryBuilder
      .match('Movie', 'm')
      .done()
      .return('m.title AS title')
      .orderBy('m.title');

    // Reset the query builder
    queryBuilder.reset();

    // Build a new query
    const cypherQuery = queryBuilder
      .match('Person', 'p')
      .done()
      .return('p.name AS name')
      .toCypher();

    // Check that the query builder was reset
    expect(cypherQuery).toContain('MATCH (p:Person)');
    expect(cypherQuery).toContain('RETURN p.name AS name');
    expect(cypherQuery).not.toContain('Movie');
    expect(cypherQuery).not.toContain('title');
  });

  // Test: Query with property constraints in vertex pattern
  it('should add property constraints to vertex pattern', () => {
    const cypherQuery = queryBuilder
      .match('Movie', 'm')
      .where('genre', '=', 'Drama')
      .where('rating', '>=', 8.5)
      .done()
      .return('m.title AS title')
      .toCypher();

    // The implementation should add property constraints to the vertex pattern
    expect(cypherQuery).toContain('MATCH (m:Movie)');
    expect(cypherQuery).toContain('RETURN m.title AS title');

    // Note: The actual implementation of property constraints in the vertex pattern
    // might vary, so this test might need adjustment
  });

  // Test: Query with property constraints in edge pattern
  it('should add property constraints to edge pattern', () => {
    const cypherQuery = queryBuilder
      .match('Person', 'p')
      .outgoing('DIRECTED', 'd', 'Movie', 'm')
      .done()
      .return('p.name AS director', 'm.title AS movie')
      .toCypher();

    // The implementation should add property constraints to the edge pattern
    expect(cypherQuery).toContain('MATCH (p:Person)');
    expect(cypherQuery).toContain('(p:Person)-[d:DIRECTED]->(m:Movie)');
    expect(cypherQuery).toContain('RETURN p.name AS director, m.title AS movie');
  });
});
