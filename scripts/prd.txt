# Product Requirements Document: Schema Loading with Single Function Approach

## Overview

This document outlines the requirements for implementing a new schema loading functionality in the ageSchemaClient library using the single-function approach demonstrated in the integration tests. This approach significantly improves the efficiency and reliability of loading graph data into Apache AGE by reducing the number of queries and providing a more robust parameter passing mechanism.

## Background

The current ageSchemaClient library provides functionality for defining and validating graph schemas but lacks an efficient mechanism for loading schema data into Apache AGE. The single-function loading approach demonstrated in the integration tests offers a solution to this problem by:

1. Storing graph data (vertices and edges) in a temporary PostgreSQL table
2. Creating PostgreSQL functions that convert this data to ag_catalog.agtype format
3. Using UNWIND in Cypher queries to process the data returned by these functions
4. Creating vertices and edges in a single operation

This approach addresses several limitations of Apache AGE:
- It avoids issues with dynamic string parameters in Cypher queries
- It provides a reliable way to pass complex data structures to Cypher
- It reduces the number of queries needed to load data

## Goals

1. Implement a core schema loading functionality that uses the single-function approach
2. Provide a simple and intuitive API for loading schema data
3. Support loading both vertices and edges in a single operation
4. Ensure type safety and validation based on the schema definition
5. Handle errors gracefully and provide meaningful error messages
6. Support transactions for atomic operations

## Non-Goals

1. Implementing a full ORM-like functionality
2. Supporting all possible graph operations (focus is on loading schema data)
3. Optimizing for extremely large datasets (beyond what can be handled in a single transaction)
4. Supporting custom SQL or Cypher queries (outside the scope of schema loading)

## User Stories

### As a developer, I want to:

1. Load a complete graph schema (vertices and edges) in a single operation
2. Have the library handle the complexity of creating temporary tables and functions
3. Receive meaningful error messages if the data doesn't match the schema
4. Be able to load data within a transaction for atomicity
5. Track the progress of loading operations for large datasets
6. Have type safety when defining the data to be loaded

## Requirements

### Functional Requirements

1. **Schema Data Loading API**
   - Create a new `SchemaLoader` class that handles loading schema data
   - Provide methods for loading vertices, edges, or both
   - Support loading data from JavaScript objects or JSON files
   - Validate data against the schema before loading

2. **Single-Function Loading Implementation**
   - Create a temporary table to store graph data
   - Generate PostgreSQL functions to convert data to ag_catalog.agtype
   - Use UNWIND in Cypher queries to process the data
   - Support loading multiple vertex and edge types in a single operation

3. **Transaction Support**
   - Allow loading operations to be part of a transaction
   - Provide rollback capability if loading fails
   - Support committing or rolling back the transaction after loading

4. **Error Handling**
   - Validate data against the schema before loading
   - Provide detailed error messages for validation failures
   - Handle database errors gracefully and provide meaningful error messages

5. **Progress Tracking**
   - Provide a mechanism to track the progress of loading operations
   - Support callbacks for progress updates
   - Return detailed statistics about the loading operation

### Technical Requirements

1. **Database Interaction**
   - Use the existing `QueryExecutor` for database operations
   - Ensure all SQL and Cypher queries are properly parameterized
   - Set the search path to include ag_catalog

2. **Schema Validation**
   - Use the existing schema validation functionality
   - Validate data against the schema before loading
   - Support custom validation functions

3. **Type Safety**
   - Provide TypeScript interfaces for all public APIs
   - Ensure type safety for schema definitions and data
   - Use generics to provide type inference based on the schema

4. **Performance**
   - Minimize the number of database queries
   - Use batch operations for loading large datasets
   - Support streaming for very large datasets

## API Design

### SchemaLoader Class

```typescript
class SchemaLoader<T extends SchemaDefinition> {
  constructor(
    schema: T,
    queryExecutor: QueryExecutor,
    options?: SchemaLoaderOptions
  );

  // Load both vertices and edges
  async loadGraphData(
    data: GraphData,
    options?: LoadOptions
  ): Promise<LoadResult>;

  // Load only vertices
  async loadVertices(
    vertices: VertexData,
    options?: LoadOptions
  ): Promise<LoadResult>;

  // Load only edges
  async loadEdges(
    edges: EdgeData,
    options?: LoadOptions
  ): Promise<LoadResult>;

  // Load from a JSON file
  async loadFromFile(
    filePath: string,
    options?: LoadOptions
  ): Promise<LoadResult>;
}
```

### Data Structures

```typescript
interface GraphData {
  vertex: Record<string, any[]>;
  edge: Record<string, any[]>;
}

interface LoadOptions {
  transaction?: Transaction;
  graphName?: string;
  batchSize?: number;
  onProgress?: (progress: ProgressInfo) => void;
  validateData?: boolean;
}

interface LoadResult {
  success: boolean;
  vertexCount: number;
  edgeCount: number;
  vertexTypes: string[];
  edgeTypes: string[];
  errors?: Error[];
  warnings?: string[];
  duration: number;
}

interface ProgressInfo {
  phase: 'validation' | 'storing' | 'creating';
  current: number;
  total: number;
  percentage: number;
  vertexCount?: number;
  edgeCount?: number;
}
```

## Implementation Plan

1. **Phase 1: Core Implementation**
   - Create the `SchemaLoader` class with basic functionality
   - Implement the single-function loading approach
   - Support loading vertices and edges
   - Add basic error handling

2. **Phase 2: Enhanced Features**
   - Add transaction support
   - Implement progress tracking
   - Support loading from files
   - Add detailed error handling and validation

3. **Phase 3: Optimization and Testing**
   - Optimize performance for large datasets
   - Add comprehensive tests
   - Create examples and documentation
   - Perform integration testing with Apache AGE

## Success Criteria

1. The schema loading functionality successfully loads vertices and edges into Apache AGE
2. The implementation uses the single-function approach to minimize queries
3. The API is intuitive and easy to use
4. The implementation handles errors gracefully
5. The implementation is well-tested and documented
6. The implementation is performant for typical use cases

## Risks and Mitigations

1. **Risk**: Apache AGE version compatibility issues
   **Mitigation**: Test with multiple versions of Apache AGE and document compatibility

2. **Risk**: Performance issues with large datasets
   **Mitigation**: Implement batch loading and streaming support

3. **Risk**: Complex error scenarios in distributed transactions
   **Mitigation**: Implement comprehensive error handling and recovery mechanisms

4. **Risk**: Type safety challenges with dynamic data
   **Mitigation**: Use TypeScript generics and runtime type checking

## Timeline

- Phase 1: 2 weeks
- Phase 2: 2 weeks
- Phase 3: 2 weeks
- Total: 6 weeks
